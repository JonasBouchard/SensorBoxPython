#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""Tkinter GUI displaying sensor data from ``latest.json``.

This interface reads the ``latest.json`` file generated by ``SensorBox.py``
to show the most recent sensor readings on an HDMI screen. Using the shared
JSON file ensures that this interface presents the same data as the other
interfaces (e.g. the web UI) without polling the sensors independently.
"""

import tkinter as tk
import sys
import json
from pathlib import Path


class Interface(tk.Tk):
    """Tkinter window displaying live sensor readings."""

    def __init__(self) -> None:
        super().__init__()
        self.title("SensorBox")
        self.geometry("320x240")  # fits small HDMI screens nicely

        # Create labels for each metric
        self.labels: dict[str, tk.Label] = {}
        metrics = [
            "eCO2",
            "TVOC",
            "Temp",
            "RH",
            "Pressure",
            "PM1",
            "PM2.5",
            "PM10",
        ]
        for name in metrics:
            lbl = tk.Label(self, text=f"{name}: --", font=("Arial", 14))
            lbl.pack(anchor="w")
            self.labels[name] = lbl

        # Path to shared JSON data produced by SensorBox.py
        self.data_file = Path(__file__).resolve().parent / "latest.json"

        self.after(1000, self.update_readings)
        self.protocol("WM_DELETE_WINDOW", self.on_close)

    # ------------------------------------------------------------------
    def update_readings(self) -> None:
        """Refresh GUI labels with values from the JSON file."""
        try:
            with self.data_file.open(encoding="utf-8") as fh:
                data = json.load(fh)
        except Exception:
            data = {}

        eco2 = data.get("eCO2")
        tvoc = data.get("TVOC")
        temp_c = data.get("Temp")
        rh = data.get("RH")
        p_pa = data.get("Pressure")
        pm1 = data.get("PM1")
        pm25 = data.get("PM2.5")
        pm10 = data.get("PM10")

        if eco2 is not None:
            self.labels["eCO2"].config(text=f"eCO2: {eco2} ppm")
        if tvoc is not None:
            self.labels["TVOC"].config(text=f"TVOC: {tvoc} ppb")
        if temp_c is not None:
            self.labels["Temp"].config(text=f"Temp: {temp_c:.1f} °C")
        if rh is not None:
            self.labels["RH"].config(text=f"RH: {rh:.2f}%")
        if p_pa is not None:
            self.labels["Pressure"].config(text=f"Pressure: {p_pa/1000:.2f} kPa")
        if pm1 is not None:
            self.labels["PM1"].config(text=f"PM1: {pm1} µg/m³")
        if pm25 is not None:
            self.labels["PM2.5"].config(text=f"PM2.5: {pm25} µg/m³")
        if pm10 is not None:
            self.labels["PM10"].config(text=f"PM10: {pm10} µg/m³")

        # Schedule next update
        self.after(1000, self.update_readings)

    # ------------------------------------------------------------------
    def on_close(self) -> None:
        """Handle window closure."""
        self.destroy()


if __name__ == "__main__":
    try:
        app = Interface()
        app.mainloop()
    except tk.TclError as err:
        print(
            "Error: Unable to start Tkinter. Ensure a graphical display is attached "
            "or X11 forwarding is enabled."
        )
        print(f"TclError: {err}")
        sys.exit(1)

